// Generated by CoffeeScript 1.6.2
(function() {
  var CoffeeMill, Deferred, coffee, colors, commander, ejs, fs, jade, path, spawn, sys, uglify,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  sys = require('sys');

  path = require('path');

  fs = require('fs');

  spawn = require('child_process').spawn;

  Deferred = require('jsdeferred').Deferred;

  commander = require('commander');

  uglify = require('uglify-js');

  colors = require('colors');

  ejs = require('ejs');

  jade = require('jade');

  coffee = require('coffee-script');

  CoffeeMill = (function() {
    CoffeeMill.rTagVersion = /^v?([0-9\.]+)$/;

    CoffeeMill.rDocComment = /\/\*\*([\s\S]+?)\*\/\s*(.*)/g;

    CoffeeMill.rParam = /@param\s+{?(\S+?)}?\s+(\S+)\s+(.*)/g;

    CoffeeMill.rReturn = /@return\s+{?(\S+?)}?\s+(.*)/g;

    CoffeeMill.rCompletelyBlank = /^\s*$/;

    CoffeeMill.rLineEndSpace = /[ \t]+$/g;

    CoffeeMill.rBreak = /[\r\n]{3,}/g;

    function CoffeeMill(cwd) {
      this.cwd = cwd;
      this.changed = __bind(this.changed, this);
      this.makefilePath = path.join(this.cwd, 'makefile.coffee');
      commander.version('0.0.1').usage('[options]').option('-w, --watch', 'watch the change of src directory').option('-v, --ver <version>', 'specify version').option('-c, --copy <path>', 'copy compiled file').parse(process.argv);
      this.readMakefile();
      this.startWatch();
      this.compile();
    }

    CoffeeMill.prototype.readMakefile = function() {
      return this.makefile = require(this.makefilePath);
    };

    CoffeeMill.prototype.startWatch = function() {
      var _ref;

      if (!commander.watch) {
        return;
      }
      fs.watch(this.makefilePath, this.changed);
      fs.watch(this.makefile.src.dir, this.changed);
      if (((_ref = this.makefile.jsdoc) != null ? _ref.template : void 0) != null) {
        return fs.watch(this.makefile.jsdoc.template, this.changed);
      }
    };

    CoffeeMill.prototype.changed = function() {
      var _this = this;

      clearTimeout(this._id);
      return this._id = setTimeout(function() {
        return _this.compile();
      }, 100);
    };

    CoffeeMill.prototype.compile = function() {
      var _this = this;

      sys.puts(new Date().toString().underline);
      return Deferred.next(function() {
        if (commander.ver != null) {
          return commander.ver;
        } else if (!_this.makefile.compiler.useGitTag) {
          return '';
        } else {
          return _this.gitTag();
        }
      }).error(function(err) {
        return '';
      }).next(function(version) {
        var className, code, codes, exp, exports, file, filePath, filePathes, filename, files, i, output, p, packageName, parentClassName, postfix, ps, r, v3SourceMap, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref;

        if (version !== '') {
          sys.puts('version: ' + version);
          postfix = "-" + version;
        } else {
          postfix = '';
        }
        if (_this.makefile.src.files != null) {
          filePathes = _this.makefile.src.files;
          for (i = _i = 0, _len = files.length; _i < _len; i = ++_i) {
            file = files[i];
            files[i] = path.join(_this.cwd, _this.makefile.src.dir, file);
          }
        } else {
          filePathes = _this.findFiles(path.join(_this.cwd, _this.makefile.src.dir));
        }
        files = [];
        for (_j = 0, _len1 = filePathes.length; _j < _len1; _j++) {
          filePath = filePathes[_j];
          code = fs.readFileSync(filePath, 'utf8');
          r = code.match(/^\s*#package\s+([\w\.]+)/);
          if (r != null) {
            r[0], packageName = r[1];
          }
          r = code.match(/^\s*class\s+(\w+)(?:\s+extends\s+(\w+))?/m);
          if (r != null) {
            r[0], className = r[1], parentClassName = r[2];
          }
          files.push({
            packageName: packageName || '',
            className: className || '',
            parentClassName: parentClassName || '',
            filePath: filePath,
            code: code
          });
        }
        files.sort(function(a, b) {
          if (b.parentClassName === a.className) {
            return -1;
          } else if (a.parentClassName === b.className) {
            return 1;
          } else {
            return 0;
          }
        });
        codes = [];
        exports = {};
        for (_k = 0, _len2 = files.length; _k < _len2; _k++) {
          file = files[_k];
          codes.push(file.code);
          ps = file.packageName.split('.');
          exp = exports;
          for (_l = 0, _len3 = ps.length; _l < _len3; _l++) {
            p = ps[_l];
            if (exp[p] == null) {
              exp[p] = {};
            }
            exp = exp[p];
          }
          exp[file.className] = file.className;
        }
        codes.push('window[k] = v for k, v of ' + JSON.stringify(exports, null, 2).replace(/(:\s+)"(\w+)"/g, '$1$2'));
        code = codes.join('\n\n');
        filename = "" + _this.makefile.dst.file + postfix + ".coffee";
        output = path.join(_this.cwd, _this.makefile.dst.dir, filename);
        fs.writeFileSync(output, code, 'utf8');
        sys.puts('concat    : '.cyan + output);
        _this.copy(code, filename);
        _ref = _this.coffee(code), code = _ref.js, v3SourceMap = _ref.v3SourceMap;
        if (_this.makefile.compiler.sourceMap) {
          code += "\n/*\n//@ sourceMappingURL=" + _this.makefile.dst.file + postfix + ".map\n*/";
        }
        filename = "" + _this.makefile.dst.file + postfix + ".js";
        output = path.join(_this.cwd, _this.makefile.dst.dir, filename);
        fs.writeFileSync(output, code, 'utf8');
        sys.puts('compile   : '.cyan + output);
        _this.copy(code, filename);
        if (_this.makefile.compiler.sourceMap) {
          filename = "" + _this.makefile.dst.file + postfix + ".map";
          output = path.join(_this.cwd, _this.makefile.dst.dir, filename);
          fs.writeFileSync(output, v3SourceMap, 'utf8');
          sys.puts('source map: '.cyan + output);
          _this.copy(code, filename);
        }
        if (_this.makefile.compiler.minify) {
          code = uglify.minify(code, {
            fromString: true
          }).code;
          filename = "" + _this.makefile.dst.file + postfix + ".min.js";
          output = path.join(_this.cwd, _this.makefile.dst.dir, filename);
          fs.writeFileSync(output, code, 'utf8');
          sys.puts('minify    : '.cyan + output);
          _this.copy(code, filename);
        }
        return sys.puts('complete!!'.green);
      }).error(function(err) {
        return sys.error(err.stack);
      });
    };

    CoffeeMill.prototype.copy = function(code, filename) {
      var output;

      if (!commander.copy) {
        return;
      }
      output = path.join(commander.copy, filename);
      fs.writeFileSync(output, code, 'utf8');
      return sys.puts('copy      : '.cyan + output);
    };

    CoffeeMill.prototype.gitTag = function() {
      var d, err, gitTag, out;

      d = new Deferred();
      gitTag = spawn('git', ['tag']);
      out = '';
      err = '';
      gitTag.stdout.setEncoding('utf8');
      gitTag.stdout.on('data', function(data) {
        return out += data;
      });
      gitTag.stderr.setEncoding('utf8');
      gitTag.stderr.on('data', function(data) {
        return err += data.red;
      });
      gitTag.on('close', function() {
        var i, minor, r, tag, tags, versions;

        if (err !== '') {
          return d.fail(err);
        }
        tags = out.split('\n');
        i = tags.length;
        while (i--) {
          tag = tags[i];
          r = tag.match(CoffeeMill.rTagVersion);
          if ((r != null ? r[1] : void 0) == null) {
            continue;
          }
          versions = r[1].split('.');
          minor = parseInt(versions[versions.length - 1], 10);
          versions[versions.length - 1] = minor + 1;
          return d.call(versions.join('.'));
        }
        return d.fail('no tag as version');
      });
      return d;
    };

    CoffeeMill.prototype.findFiles = function(dir, files) {
      var file, stats, _i, _len, _ref;

      if (files == null) {
        files = [];
      }
      _ref = fs.readdirSync(dir);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        file = _ref[_i];
        file = path.join(dir, file);
        stats = fs.statSync(file);
        if (stats.isFile()) {
          files.push(file);
        } else if (stats.isDirectory()) {
          this.findFiles(file, files);
        }
      }
      return files;
    };

    CoffeeMill.prototype.jsdoc = function(wholeCode) {
      var code, comment, doc, file, files, generateDoc, i, name, params, properties, r, r2, returns, _i, _len;

      if (this.makefile.jsdoc.src.files != null) {
        files = this.makefile.jsdoc.src.files;
        for (i = _i = 0, _len = files.length; _i < _len; i = ++_i) {
          file = files[i];
          files[i] = path.join(this.cwd, this.makefile.jsdoc.src.dir, file);
        }
        code = this.concatFiles(files);
      } else {
        code = wholeCode;
      }
      properties = [];
      while (r = CoffeeMill.rDocComment.exec(code)) {
        comment = r[1];
        name = r[2];
        params = [];
        returns = [];
        comment = comment.replace(/^[ \t]*\/\/.*$/g, '').replace(/^[ \t]*\* ?/g, '');
        comment = comment.replace(CoffeeMill.rParam, function(matched, type, name, description) {
          var optional, r;

          optional = false;
          if (r = name.match(/^\[(.*)\]$/)) {
            optional = true;
            name = r[1];
          }
          r = name.split('=');
          params.push({
            types: type.split('|'),
            optional: optional,
            name: r[0],
            defaultValue: r[1],
            description: description
          });
          return '';
        });
        comment = comment.replace(CoffeeMill.rReturn, function(matched, type, description) {
          returns.push({
            types: type.split('|'),
            description: description
          });
          return '';
        });
        if (CoffeeMill.rCompletelyBlank.test(comment)) {
          continue;
        }
        r2 = name.match(/(\S+)\s*[:=]/);
        if (typeof r2 === "function" ? r2([1] != null) : void 0) {
          name = r2[1];
        }
        properties.push({
          name: name,
          comment: comment,
          params: params,
          returns: returns
        });
      }
      switch (this.makefile.jsdoc.engine) {
        case 'ejs':
          generateDoc = ejs.compile(fs.readFileSync(this.makefile.jsdoc.template, 'utf8'), {
            compileDebug: true
          });
          doc = generateDoc({
            title: rawFilename,
            properties: properties
          }).replace(CoffeeMill.rLineEndSpace, '').replace(CoffeeMill.rBreak, '\n\n');
          return fs.writeFileSync(this.makefile.jsdoc.filename, doc, 'utf8');
        case 'jade':
          generateDoc = jade.compile(fs.readFileSync(this.makefile.jsdoc.template, 'utf8'), {
            compileDebug: true
          });
          doc = generateDoc({
            title: rawFilename,
            properties: properties
          }).replace(CoffeeMill.rLineEndSpace, '').replace(CoffeeMill.rBreak, '\n\n');
          return fs.writeFileSync(this.makefile.jsdoc.filename, doc, 'utf8');
      }
    };

    CoffeeMill.prototype.concatFiles = function(files) {
      var codes, file, _i, _len;

      codes = [];
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        codes.push(fs.readFileSync(file, 'utf8'));
      }
      return codes.join('\n\n');
    };

    CoffeeMill.prototype.coffee = function(code) {
      var err;

      try {
        return coffee.compile(code, {
          sourceMap: true
        });
      } catch (_error) {
        err = _error;
        return sys.puts(("Compile Error: " + (err.toString())).red);
      }
    };

    return CoffeeMill;

  })();

  exports.run = function() {
    return new CoffeeMill(process.cwd());
  };

}).call(this);

/*
//@ sourceMappingURL=coffeemill.map
*/
