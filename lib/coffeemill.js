// Generated by CoffeeScript 1.6.2
(function() {
  var CoffeeMill, Deferred, coffee, colors, commander, ejs, fs, jade, path, spawn, uglify, util,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  util = require('util');

  path = require('path');

  fs = require('fs');

  spawn = require('child_process').spawn;

  Deferred = require('jsdeferred').Deferred;

  commander = require('commander');

  uglify = require('uglify-js');

  colors = require('colors');

  ejs = require('ejs');

  jade = require('jade');

  coffee = require('coffee-script');

  CoffeeMill = (function() {
    var EXT_NAMES;

    EXT_NAMES = ['.coffee'];

    CoffeeMill.rTagVersion = /^v?([0-9\.]+)$/;

    CoffeeMill.rDocComment = /\/\*\*([\s\S]+?)\*\/\s*(.*)/g;

    CoffeeMill.rParam = /@param\s+{?(\S+?)}?\s+(\S+)\s+(.*)/g;

    CoffeeMill.rReturn = /@return\s+{?(\S+?)}?\s+(.*)/g;

    CoffeeMill.rCompletelyBlank = /^\s*$/;

    CoffeeMill.rLineEndSpace = /[ \t]+$/g;

    CoffeeMill.rBreak = /[\r\n]{3,}/g;

    function CoffeeMill(cwd) {
      var list;

      this.cwd = cwd;
      this.changed = __bind(this.changed, this);
      list = function(val) {
        return val.split(',');
      };
      commander.version(JSON.parse(fs.readFileSync(path.join(__dirname, '..', 'package.json'))).version).usage('[options]').option('-n, --name <basename>', 'output directory (defualt is \'\')', '').option('-i, --input <dirnames>', 'output directory (defualt is \'src\')', list, ['src']).option('-o, --output <dirnames>', 'output directory (defualt is \'lib\')', list, ['lib']).option('-u, --uglify', 'minify with uglifyJS (.min.js)').option('-m, --map', 'generate source maps (.map)').option('-w, --watch', 'watch the change of input directory recursively').option('-v, --ver <version>', 'file version: supports version string, \'gitTag\' or \'none\' (default is \'none\')', 'none').option('--jsDoc', 'generate jsDoc').option('--jsDocEngine <engine>', 'jsDoc template engine (default is \'ejs\')', 'ejs').option('--jsDocTemplate <filename>', 'jsDoc template', 'README.ejs').option('--jsDocOutput <filename>', 'jsDoc output', 'README.md').parse(process.argv);
      this.run();
    }

    CoffeeMill.prototype.run = function() {
      process.stdout.write('\u001B[2J\u001B[0;0f');
      util.puts(new Date().toString().underline);
      this.scanInput();
      return this.compile();
    };

    CoffeeMill.prototype.scanInput = function() {
      var watcher, _i, _len, _ref;

      if (this.watchers != null) {
        _ref = this.watchers;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          watcher = _ref[_i];
          watcher.close();
        }
      }
      this.watchers = [];
      this.hasError = false;
      return this.files = this.findFiles(commander.input, commander.watch ? this.changed : null);
    };

    CoffeeMill.prototype.findFiles = function(dirs, change, basedir, files) {
      var childs, className, code, dir, dirPath, err, extendsClassName, extname, file, filePath, filename, i, isBasedir, name, namespace, namespaces, packages, r, stats, _i, _j, _len, _len1;

      if (files == null) {
        files = [];
      }
      isBasedir = basedir != null;
      for (_i = 0, _len = dirs.length; _i < _len; _i++) {
        dir = dirs[_i];
        if (isBasedir) {
          dirPath = dir;
        } else {
          dirPath = basedir = dir;
        }
        stats = fs.statSync(dirPath);
        if (stats.isFile()) {
          filePath = dirPath;
          if (EXT_NAMES.indexOf(path.extname(filePath)) !== -1) {
            packages = path.relative(basedir, filePath).split(path.sep);
            packages.pop();
            filename = path.basename(filePath);
            extname = path.extname(filePath);
            name = path.basename(filePath, extname);
            code = fs.readFileSync(filePath, 'utf8');
            if (extname === '.coffee') {
              try {
                coffee.compile(code);
              } catch (_error) {
                err = _error;
                this.hasError = true;
                this.reportCompileError(filename, code, err);
              }
            }
            r = code.match(/class\s+(\S+)(?:\s+extends\s+(\S+))?/m);
            if (r != null) {
              r[0], className = r[1], extendsClassName = r[2];
            }
            namespaces = packages.concat([name]);
            namespace = namespaces.join('.');
            if ((className != null) && className !== namespace) {
              util.puts(("class name isn't '" + namespace + "' (" + filePath + ")").yellow);
            }
            files.push({
              filePath: filePath,
              extname: extname,
              packages: packages,
              name: name,
              namespaces: namespaces,
              namespace: namespace,
              className: className,
              extendsClassName: extendsClassName,
              code: code
            });
          }
        } else if (stats.isDirectory()) {
          if (change != null) {
            this.watchers.push(fs.watch(dirPath, change));
          }
          childs = fs.readdirSync(dirPath);
          for (i = _j = 0, _len1 = childs.length; _j < _len1; i = ++_j) {
            file = childs[i];
            childs[i] = path.join(dirPath, file);
          }
          this.findFiles(childs, change, basedir, files);
        }
      }
      return files;
    };

    CoffeeMill.prototype.changed = function() {
      clearTimeout(this.timeoutId);
      return this.run();
    };

    CoffeeMill.prototype.compile = function() {
      var cs, csName,
        _this = this;

      if (this.hasError) {
        return;
      }
      cs = '';
      csName = '';
      return Deferred.next(function() {
        switch (commander.ver) {
          case 'none':
            return '';
          case 'gitTag':
            return _this.gitTag();
          default:
            return commander.ver;
        }
      }).error(function(err) {
        return '';
      }).next(function(version) {
        var className, classNames, code, codes, data, dependency, exp, exports, extendsClassName, filename, i, j, js, k, map, name, namespace, outputDir, outputPath, outputs, packages, pkg, postfix, type, uglified, v, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;

        if (version !== '') {
          util.puts('version: ' + version);
          postfix = "-" + version;
        } else {
          postfix = '';
        }
        dependency = [];
        classNames = [];
        _ref = _this.files;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          className = _ref[_i].className;
          classNames.push(className);
        }
        i = _this.files.length;
        while (i--) {
          extendsClassName = _this.files[i].extendsClassName;
          if ((extendsClassName == null) || classNames.indexOf(extendsClassName) === -1) {
            dependency.unshift(_this.files.splice(i, 1)[0]);
          }
        }
        while (i = _this.files.length) {
          while (i--) {
            extendsClassName = _this.files[i].extendsClassName;
            for (j = _j = 0, _len1 = dependency.length; _j < _len1; j = ++_j) {
              className = dependency[j].className;
              if (className === extendsClassName) {
                dependency.splice(j + 1, 0, _this.files.splice(i, 1)[0]);
                break;
              }
            }
          }
        }
        _this.files = dependency;
        codes = [];
        exports = {};
        _ref1 = _this.files;
        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
          _ref2 = _ref1[_k], code = _ref2.code, name = _ref2.name, className = _ref2.className, packages = _ref2.packages, namespace = _ref2.namespace;
          codes.push(code);
          exp = exports;
          for (_l = 0, _len3 = packages.length; _l < _len3; _l++) {
            pkg = packages[_l];
            if (exp[pkg] == null) {
              exp[pkg] = {};
            }
            exp = exp[pkg];
          }
        }
        for (k in exports) {
          v = exports[k];
          codes.unshift("" + k + " = " + (JSON.stringify(v, null, 2)) + "\nif window? then window." + k + " = " + k + "\nif module? then module.exports = " + k);
        }
        cs = codes.join('\n\n');
        csName = "" + commander.name + postfix + ".coffee";
        outputs = [];
        outputs.push({
          type: '.coffee',
          filename: csName,
          data: cs
        });
        _ref3 = coffee.compile(cs, {
          sourceMap: true,
          generatedFile: "" + commander.name + postfix + ".js",
          sourceRoot: '',
          sourceFiles: ["" + commander.name + postfix + ".coffee"]
        }), js = _ref3.js, map = _ref3.v3SourceMap;
        if (commander.map) {
          js += "\n/*\n//@ sourceMappingURL=" + commander.name + postfix + ".map\n*/";
        }
        outputs.push({
          type: '.js    ',
          filename: "" + commander.name + postfix + ".js",
          data: js
        });
        if (commander.map) {
          outputs.push({
            type: '.map   ',
            filename: "" + commander.name + postfix + ".map",
            data: map
          });
        }
        if (commander.uglify) {
          uglified = uglify.minify(js, {
            fromString: true
          }).uglified;
          outputs.push({
            type: '.min.js',
            filename: "" + commander.name + postfix + ".min.js",
            data: uglified
          });
        }
        _ref4 = commander.output;
        for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
          outputDir = _ref4[_m];
          outputDir = path.resolve(_this.cwd, outputDir);
          if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir);
          }
          for (_n = 0, _len5 = outputs.length; _n < _len5; _n++) {
            _ref5 = outputs[_n], type = _ref5.type, filename = _ref5.filename, data = _ref5.data;
            outputPath = path.resolve(_this.cwd, path.join(outputDir, filename));
            fs.writeFileSync(outputPath, data, 'utf8');
            util.puts(("" + type + ": ").cyan + path.relative('.', outputPath));
          }
        }
        return util.puts('√'.green);
      }).error(function(err) {
        if (err.location != null) {
          return _this.reportCompileError(csName, cs, err);
        } else {
          return util.error(("" + err.stack).red);
        }
      });
    };

    CoffeeMill.prototype.reportCompileError = function(csName, cs, err) {
      var after, before, code, error, first_column, first_line, last_column, last_line, lines, _ref;

      _ref = err.location, first_line = _ref.first_line, first_column = _ref.first_column, last_line = _ref.last_line, last_column = _ref.last_column;
      lines = cs.split('\n');
      code = lines.splice(first_line, last_line - first_line + 1).join('\n');
      before = code.substring(0, first_column);
      error = code.substring(first_column, last_column + 1);
      after = code.substring(last_column + 1);
      return util.error("" + ("" + csName + ":" + first_line + ":" + first_column + " " + (err.toString())).red + "\n" + before + error.red.inverse + after);
    };

    CoffeeMill.prototype.jsDoc = function(code) {
      var comment, doc, generateDoc, name, params, properties, r, r2, returns;

      properties = [];
      while (r = CoffeeMill.rDocComment.exec(code)) {
        comment = r[1];
        name = r[2];
        params = [];
        returns = [];
        comment = comment.replace(/^[ \t]*\/\/.*$/g, '').replace(/^[ \t]*\* ?/g, '');
        comment = comment.replace(CoffeeMill.rParam, function(matched, type, name, description) {
          var optional, r;

          optional = false;
          if (r = name.match(/^\[(.*)\]$/)) {
            optional = true;
            name = r[1];
          }
          r = name.split('=');
          params.push({
            types: type.split('|'),
            optional: optional,
            name: r[0],
            defaultValue: r[1],
            description: description
          });
          return '';
        });
        comment = comment.replace(CoffeeMill.rReturn, function(matched, type, description) {
          returns.push({
            types: type.split('|'),
            description: description
          });
          return '';
        });
        if (CoffeeMill.rCompletelyBlank.test(comment)) {
          continue;
        }
        r2 = name.match(/(\S+)\s*[:=]/);
        if (typeof r2 === "function" ? r2([1] != null) : void 0) {
          name = r2[1];
        }
        properties.push({
          name: name,
          comment: comment,
          params: params,
          returns: returns
        });
      }
      switch (this.makefile.jsdoc.engine) {
        case 'ejs':
          generateDoc = ejs.compile(fs.readFileSync(this.makefile.jsdoc.template, 'utf8'), {
            compileDebug: true
          });
          doc = generateDoc({
            title: rawFilename,
            properties: properties
          }).replace(CoffeeMill.rLineEndSpace, '').replace(CoffeeMill.rBreak, '\n\n');
          return fs.writeFileSync(this.makefile.jsdoc.filename, doc, 'utf8');
        case 'jade':
          generateDoc = jade.compile(fs.readFileSync(this.makefile.jsdoc.template, 'utf8'), {
            compileDebug: true
          });
          doc = generateDoc({
            title: rawFilename,
            properties: properties
          }).replace(CoffeeMill.rLineEndSpace, '').replace(CoffeeMill.rBreak, '\n\n');
          return fs.writeFileSync(this.makefile.jsdoc.filename, doc, 'utf8');
      }
    };

    CoffeeMill.prototype.indent = function(code) {
      var i, line, lines, _i, _len;

      lines = code.split(/\r?\n/g);
      for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {
        line = lines[i];
        lines[i] = '  ' + line;
      }
      return lines.join('\n');
    };

    CoffeeMill.prototype.gitTag = function() {
      var d, err, gitTag, out;

      d = new Deferred();
      gitTag = spawn('git', ['tag']);
      out = '';
      gitTag.stdout.setEncoding('utf8');
      gitTag.stdout.on('data', function(data) {
        return out += data;
      });
      err = '';
      gitTag.stderr.setEncoding('utf8');
      gitTag.stderr.on('data', function(data) {
        return err += data.red;
      });
      gitTag.on('close', function() {
        var i, minor, r, tag, tags, versions;

        if (err !== '') {
          return d.fail(err);
        }
        tags = out.split('\n');
        i = tags.length;
        while (i--) {
          tag = tags[i];
          r = tag.match(CoffeeMill.rTagVersion);
          if ((r != null ? r[1] : void 0) == null) {
            continue;
          }
          versions = r[1].split('.');
          minor = parseInt(versions[versions.length - 1], 10);
          versions[versions.length - 1] = minor + 1;
          d.call(versions.join('.'));
          return;
        }
        return d.fail('no tag as version');
      });
      return d;
    };

    return CoffeeMill;

  })();

  exports.run = function() {
    return new CoffeeMill(process.cwd());
  };

}).call(this);

/*
//@ sourceMappingURL=coffeemill.map
*/
